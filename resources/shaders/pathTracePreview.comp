#version 460
#extension GL_EXT_shader_explicit_arithmetic_types_int64 : require

layout (local_size_x = 16, local_size_y = 16) in;

#include "Common/random.glsl"
#include "Common/Material.glsl"

struct triangle
{
    vec3 v0;
    float padding0;
    vec3 v1;
    float padding1;
    vec3 v2;
    float padding2; 
    vec3 Centroid;
    float padding3;     
};

struct triangleExtraData
{
    vec3 Normal0; 
    float padding0;
    vec3 Normal1; 
    float padding1;
    vec3 Normal2; 
    float padding2;
    vec2 UV0, UV1, UV2; 
    vec2 padding3;
};
struct bvhNode
{
    vec3 AABBMin;
    float padding0;
    vec3 AABBMax;
    float padding1;
    uint LeftChildOrFirst;
    uint TriangleCount;
    uvec2 padding2;    
};

struct indexData
{
    uint triangleDataStartInx;
    uint IndicesDataStartInx;
    uint BVHNodeDataStartInx;
    uint MaterialIndex;
};

struct aabb
{
    vec3 Min;
    float pad0;
    vec3 Max;
    float pad1;
};

struct bvhInstance
{
    mat4 InverseTransform;
    aabb Bounds;
    
    uint MeshIndex;
    uint Index;
    ivec2 pad0;
    
    ivec4 pad1;
};

struct tlasNode
{
    vec3 AABBMin;
    uint LeftRight;
    vec3 AABBMax;
    uint BLAS;
};




layout (set=0, binding = 0, rgba8) uniform  image2D shadowImage;
layout (set=0, binding = 1) readonly buffer triangleBuffer
{
    triangle Triangles[];
} TriangleBuffer;

layout (set=0, binding = 2) readonly buffer triangleExBuffer
{
    triangleExtraData TrianglesEx[];
} TriangleExBuffer;

layout (set=0, binding = 3) readonly buffer bvhBuffer
{
    bvhNode Nodes[];
} BVHBuffer;

layout (set=0, binding = 4) readonly buffer indicesBuffer
{
    uint Indices[];
} IndicesBuffer;

layout (set=0, binding = 5) readonly buffer indexDataBuffer
{
    indexData IndexData[];
} IndexDataBuffer;

layout (set=0, binding = 6) readonly buffer tlasInstancesBuffer
{
    bvhInstance Instances[];
} TLASInstancesBuffer;

layout (set=0, binding = 7) readonly buffer tlasNodes
{
    tlasNode Nodes[];
} TLASNodes;

layout (set=0, binding = 8) readonly buffer materialData
{
    material Data[];
} MaterialData;

#include "Common/SceneUBO.glsl"
layout (set=1, binding = 0) uniform UBO 
{
    sceneUbo Data;
} SceneUbo;



struct ray
{
    vec3 Origin;
    vec3 Direction;
    vec3 InverseDirection;
};


struct rayPayload
{
    float Distance;
    vec3 Emission;
    
    vec3 Color;
	float Roughness;
    
    uint InstanceIndex;
    uint PrimitiveIndex;
    uint RandomState;
	uint Depth;
    
	vec3 Normal;
	uint MaterialIndex;
    
    float U, V;
    vec2 padding;
};

float RayAABBIntersection(ray Ray, vec3 AABBMin, vec3 AABBMax, inout  rayPayload RayPayload)
{
    float tx1 = (AABBMin.x - Ray.Origin.x) * Ray.InverseDirection.x, tx2 = (AABBMax.x - Ray.Origin.x) * Ray.InverseDirection.x;
    float tmin = min( tx1, tx2 ), tmax = max( tx1, tx2 );
    float ty1 = (AABBMin.y - Ray.Origin.y) * Ray.InverseDirection.y, ty2 = (AABBMax.y - Ray.Origin.y) * Ray.InverseDirection.y;
    tmin = max( tmin, min( ty1, ty2 ) ), tmax = min( tmax, max( ty1, ty2 ) );
    float tz1 = (AABBMin.z - Ray.Origin.z) * Ray.InverseDirection.z, tz2 = (AABBMax.z - Ray.Origin.z) * Ray.InverseDirection.z;
    tmin = max( tmin, min( tz1, tz2 ) ), tmax = min( tmax, max( tz1, tz2 ) );
    if(tmax >= tmin && tmin < RayPayload.Distance && tmax > 0) return tmin;
    else return 1e30f;    
}

void RayTriangleInteresection(ray Ray, triangle Triangle, inout rayPayload RayPayload, uint InstanceIndex, uint PrimitiveIndex)
{
    vec3 Edge1 = Triangle.v1 - Triangle.v0;
    vec3 Edge2 = Triangle.v2 - Triangle.v0;

    vec3 h = cross(Ray.Direction, Edge2);
    float a = dot(Edge1, h);
    if(a > -0.0001f && a < 0.0001f) return; //Ray is parallel to the triangle
    
    float f = 1 / a;
    vec3 s = Ray.Origin - Triangle.v0;
    float u = f * dot(s, h);
    if(u < 0 || u > 1) return;

    vec3 q = cross(s, Edge1);
    float v = f * dot(Ray.Direction, q);
    if(v < 0 || u + v > 1) return;
    
    float t = f * dot(Edge2, q);
    if(t > 0.0001f && t < RayPayload.Distance) {
        RayPayload.U = u;
        RayPayload.V = v;
        RayPayload.InstanceIndex = InstanceIndex;
        RayPayload.Distance = t;
        RayPayload.PrimitiveIndex = PrimitiveIndex;
    }
}

void IntersectBVH(ray Ray, inout rayPayload RayPayload, uint InstanceIndex, uint MeshIndex)
{
    uint NodeInx = 0;
    uint Stack[64];
    uint StackPointer=0;
    bool t=true;
    
    // int MeshIndex=5;
    indexData IndexData = IndexDataBuffer.IndexData[MeshIndex];
    uint NodeStartInx = IndexData.BVHNodeDataStartInx;
    uint TriangleStartInx = IndexData.triangleDataStartInx;
    uint IndexStartInx = IndexData.IndicesDataStartInx;
    uint MaterialIndex = IndexData.MaterialIndex;
        

    while(t)
    {
        if(BVHBuffer.Nodes[NodeStartInx + NodeInx].TriangleCount>0)
        {
            for(uint i=0; i<BVHBuffer.Nodes[NodeStartInx + NodeInx].TriangleCount; i++)
            {
                uint Index = TriangleStartInx + IndicesBuffer.Indices[IndexStartInx + BVHBuffer.Nodes[NodeStartInx + NodeInx].LeftChildOrFirst + i] ;
                RayTriangleInteresection(Ray, 
                                         TriangleBuffer.Triangles[Index], 
                                         RayPayload, 
                                         InstanceIndex, 
                                         Index);
                RayPayload.MaterialIndex = MaterialIndex;
            }
            if(StackPointer==0) break;
            else NodeInx = Stack[--StackPointer];
            continue;
        }

        uint Child1 = BVHBuffer.Nodes[NodeStartInx + NodeInx].LeftChildOrFirst;
        uint Child2 = BVHBuffer.Nodes[NodeStartInx + NodeInx].LeftChildOrFirst+1;

        float Dist1 = RayAABBIntersection(Ray, BVHBuffer.Nodes[Child1 + NodeStartInx].AABBMin, BVHBuffer.Nodes[Child1 + NodeStartInx].AABBMax, RayPayload);
        float Dist2 = RayAABBIntersection(Ray, BVHBuffer.Nodes[Child2 + NodeStartInx].AABBMin, BVHBuffer.Nodes[Child2 + NodeStartInx].AABBMax, RayPayload);
        if(Dist1 > Dist2) {
            float tmpDist = Dist2;
            Dist2 = Dist1;
            Dist1 = tmpDist;

            uint tmpChild = Child2;
            Child2 = Child1;
            Child1 = tmpChild;
        }

        if(Dist1 == 1e30f)
        {
            if(StackPointer==0) break;
            else NodeInx = Stack[--StackPointer];
        }
        else
        {
            NodeInx = Child1;
            if(Dist2 != 1e30f)
            {
                Stack[StackPointer++] = Child2;
            }   
        }
    }
}

void IntersectInstance(ray Ray, inout rayPayload RayPayload, uint InstanceIndex)
{
    mat4 InverseTransform = TLASInstancesBuffer.Instances[InstanceIndex].InverseTransform;
    Ray.Origin = (InverseTransform * vec4(Ray.Origin, 1)).xyz;
    Ray.Direction = (InverseTransform * vec4(Ray.Direction, 0)).xyz;
    Ray.InverseDirection = 1.0f / Ray.Direction;

    IntersectBVH(Ray, RayPayload, TLASInstancesBuffer.Instances[InstanceIndex].Index, TLASInstancesBuffer.Instances[InstanceIndex].MeshIndex);
}

void IntersectTLAS(ray Ray, inout rayPayload RayPayload)
{
    Ray.InverseDirection = 1.0f / Ray.Direction;
    uint NodeInx = 0;
    uint Stack[64];
    uint StackPtr=0;
    while(true)
    {
        //If we hit the leaf, check intersection with the bvhs
        if(TLASNodes.Nodes[NodeInx].LeftRight==0)
        {
            IntersectInstance(Ray, RayPayload, TLASNodes.Nodes[NodeInx].BLAS);
            
            if(StackPtr == 0) break;
            else NodeInx = Stack[--StackPtr];
            continue;
        }

        //Check if hit any of the children
        uint Child1 = TLASNodes.Nodes[NodeInx].LeftRight & 0xffff;
        uint Child2 = TLASNodes.Nodes[NodeInx].LeftRight >> 16;
        
        float Dist1 = RayAABBIntersection(Ray, TLASNodes.Nodes[Child1].AABBMin, TLASNodes.Nodes[Child1].AABBMax, RayPayload);
        float Dist2 = RayAABBIntersection(Ray, TLASNodes.Nodes[Child2].AABBMin, TLASNodes.Nodes[Child2].AABBMax, RayPayload);
        if(Dist1 > Dist2) { //Swap if dist 2 is closer
            float tmpDist = Dist2;
            Dist2 = Dist1;
            Dist1 = tmpDist;

            uint tmpChild = Child2;
            Child2 = Child1;
            Child1 = tmpChild;            
        }
        
        if(Dist1 == 1e30f) //We didn't hit a child
        {
            if(StackPtr == 0) break; //There's no node left to explore
            else NodeInx = Stack[--StackPtr]; //Go to the next node in the stack
        }
        else //We hit a child
        {
            NodeInx = Child1; //Set the current node to the first child
            if(Dist2 != 1e30f) Stack[StackPtr++] = Child2; //If we also hit the other node, add it in the stack
        }

    }
}


void main() 
{	  
    ivec2 dim = imageSize(shadowImage);
    vec2 uv = vec2(gl_GlobalInvocationID.xy) / dim;
    
    ray Ray;
    Ray.Origin = (SceneUbo.Data.InvView * vec4(0.0, 0.0, 0.0, 1.0)).xyz;
    vec4 Target = SceneUbo.Data.InvProjection * vec4((vec2(gl_GlobalInvocationID.xy)) / dim * 2.0 - 1.0, 0.0, 1.0);
    Ray.Direction = (SceneUbo.Data.InvView * vec4(normalize(Target.xyz), 0.0)).xyz;
    Ray.InverseDirection = 1 / Ray.Direction;

    rayPayload PayLoad;
    PayLoad.Distance = 1e30f;
    // IntersectInstance(Ray, PayLoad, 0);
    // IntersectBVH(Ray, PayLoad, 0,27);
    IntersectTLAS(Ray,PayLoad);
    imageStore(shadowImage, ivec2(gl_GlobalInvocationID.xy), vec4(uv,0,1));
    if(PayLoad.Distance < 1e30f)
    {
        material Material = MaterialData.Data[PayLoad.MaterialIndex];
        triangleExtraData ExtraData = TriangleExBuffer.TrianglesEx[PayLoad.PrimitiveIndex];
        
        // vulkanTexture *DiffuseTexture = &Material->Diffuse;
        
        // bvh *BVH =  Instances[RayPayload.InstanceIndex].Meshes->at(Instances[RayPayload.InstanceIndex].MeshIndex)->BVH;

        // glm::vec2 UV = 
        //     BVH->Mesh->TrianglesExtraData[RayPayload.PrimitiveIndex].UV1 * RayPayload.U + 
        //     BVH->Mesh->TrianglesExtraData[RayPayload.PrimitiveIndex].UV2 * RayPayload.V +
        //     BVH->Mesh->TrianglesExtraData[RayPayload.PrimitiveIndex].UV0 * (1 - RayPayload.U - RayPayload.V);

        vec3 FinalColor = vec3(0);

        vec3 BaseColor = Material.BaseColor;
        // if(MatData->BaseColorTextureID >=0 && MatData->UseBaseColor>0)
        // {
        //     glm::vec4 TextureColor = DiffuseTexture->Sample(UV);
            
        //     TextureColor *= glm::pow(TextureColor, glm::vec4(2.2f));
        //     BaseColor *= glm::vec3(TextureColor);                    
        // }                

        FinalColor += BaseColor;
        // FinalColor = toneMap(FinalColor, App->Scene->UBOSceneMatrices.Exposure);
        
        imageStore(shadowImage, ivec2(gl_GlobalInvocationID.xy), vec4(FinalColor,1));
    }

}

