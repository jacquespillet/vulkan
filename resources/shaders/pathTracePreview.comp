#version 460
#extension GL_EXT_shader_explicit_arithmetic_types_int64 : require
#extension GL_EXT_nonuniform_qualifier : enable


#define DIFFUSE_TYPE 1
#define SPECULAR_TYPE 2

layout (local_size_x = 16, local_size_y = 16) in;

#include "Common/random.glsl"
#include "Common/Material.glsl"
#include "Common/Tonemapping.glsl"

struct triangle
{
    vec3 v0;
    float padding0;
    vec3 v1;
    float padding1;
    vec3 v2;
    float padding2; 
    vec3 Centroid;
    float padding3;     
};

struct triangleExtraData
{
    vec3 Normal0; 
    float padding0;
    vec3 Normal1; 
    float padding1;
    vec3 Normal2; 
    float padding2;
    vec2 UV0, UV1, UV2; 
    vec2 padding3;
};
struct bvhNode
{
    vec3 AABBMin;
    float padding0;
    vec3 AABBMax;
    float padding1;
    uint LeftChildOrFirst;
    uint TriangleCount;
    uvec2 padding2;    
};

struct indexData
{
    uint triangleDataStartInx;
    uint IndicesDataStartInx;
    uint BVHNodeDataStartInx;
    uint MaterialIndex;
};

struct aabb
{
    vec3 Min;
    float pad0;
    vec3 Max;
    float pad1;
};

struct bvhInstance
{
    mat4 InverseTransform;
    aabb Bounds;
    
    uint MeshIndex;
    uint Index;
    ivec2 pad0;
    
    ivec4 pad1;
};

struct tlasNode
{
    vec3 AABBMin;
    uint LeftRight;
    vec3 AABBMax;
    uint BLAS;
};

struct uniformData
{
    uint VertexSize;
    uint CurrentSampleCount;
    int SamplersPerFrame;
    int RayBounces;

    int MaxSamples ;
    int ShouldAccumulate;
    ivec2 Padding;
};


layout (set=0, binding = 0, rgba8) uniform  image2D FinalImage;
layout (set=0, binding = 1) readonly buffer triangleBuffer
{
    triangle Triangles[];
} TriangleBuffer;

layout (set=0, binding = 2) readonly buffer triangleExBuffer
{
    triangleExtraData TrianglesEx[];
} TriangleExBuffer;

layout (set=0, binding = 3) readonly buffer bvhBuffer
{
    bvhNode Nodes[];
} BVHBuffer;

layout (set=0, binding = 4) readonly buffer indicesBuffer
{
    uint Indices[];
} IndicesBuffer;

layout (set=0, binding = 5) readonly buffer indexDataBuffer
{
    indexData IndexData[];
} IndexDataBuffer;

layout (set=0, binding = 6) readonly buffer tlasInstancesBuffer
{
    bvhInstance Instances[];
} TLASInstancesBuffer;

layout (set=0, binding = 7) readonly buffer tlasNodes
{
    tlasNode Nodes[];
} TLASNodes;

layout (set=0, binding = 8) readonly buffer materialData
{
    material Data[];
} MaterialData;

layout(set = 0, binding = 9) uniform sampler2D[] textures;

#include "Common/ubo.glsl"
layout(set = 0, binding = 10) uniform UniformData { Ubo ubo; };

layout (set=0, binding = 11, rgba8) uniform  image2D AccumulationImage;

#include "Common/SceneUBO.glsl"
layout (set=1, binding = 0) uniform UBO 
{
    sceneUbo Data;
} SceneUbo;



struct ray
{
    vec3 Origin;
    vec3 Direction;
    vec3 InverseDirection;
};


struct rayPayload
{
    float Distance;
    vec3 Emission;
    
    vec3 Color;
	float Roughness;
    
    uint InstanceIndex;
    uint PrimitiveIndex;
    uint RandomState;
	uint Depth;
    
	vec3 Normal;
	uint MaterialIndex;
    
    float U, V;
    float Metallic;
    float padding;
} RayPayload;


#include "rtx/BRDF.glsl"
#include "Common/Defines.glsl"


float RayAABBIntersection(ray Ray, vec3 AABBMin, vec3 AABBMax, inout  rayPayload RayPayload)
{
    float tx1 = (AABBMin.x - Ray.Origin.x) * Ray.InverseDirection.x, tx2 = (AABBMax.x - Ray.Origin.x) * Ray.InverseDirection.x;
    float tmin = min( tx1, tx2 ), tmax = max( tx1, tx2 );
    float ty1 = (AABBMin.y - Ray.Origin.y) * Ray.InverseDirection.y, ty2 = (AABBMax.y - Ray.Origin.y) * Ray.InverseDirection.y;
    tmin = max( tmin, min( ty1, ty2 ) ), tmax = min( tmax, max( ty1, ty2 ) );
    float tz1 = (AABBMin.z - Ray.Origin.z) * Ray.InverseDirection.z, tz2 = (AABBMax.z - Ray.Origin.z) * Ray.InverseDirection.z;
    tmin = max( tmin, min( tz1, tz2 ) ), tmax = min( tmax, max( tz1, tz2 ) );
    if(tmax >= tmin && tmin < RayPayload.Distance && tmax > 0) return tmin;
    else return 1e30f;    
}

void RayTriangleInteresection(ray Ray, triangle Triangle, inout rayPayload RayPayload, uint InstanceIndex, uint PrimitiveIndex, uint MaterialIndex)
{
    vec3 Edge1 = Triangle.v1 - Triangle.v0;
    vec3 Edge2 = Triangle.v2 - Triangle.v0;

    vec3 h = cross(Ray.Direction, Edge2);
    float a = dot(Edge1, h);
    if(a > -0.0001f && a < 0.0001f) return; //Ray is parallel to the triangle
    
    float f = 1 / a;
    vec3 s = Ray.Origin - Triangle.v0;
    float u = f * dot(s, h);
    if(u < 0 || u > 1) return;

    vec3 q = cross(s, Edge1);
    float v = f * dot(Ray.Direction, q);
    if(v < 0 || u + v > 1) return;
    
    float t = f * dot(Edge2, q);
    if(t > 0.0001f && t < RayPayload.Distance) {
        RayPayload.U = u;
        RayPayload.V = v;
        RayPayload.InstanceIndex = InstanceIndex;
        RayPayload.Distance = t;
        RayPayload.PrimitiveIndex = PrimitiveIndex;
        RayPayload.MaterialIndex = MaterialIndex;
    }
}

void IntersectBVH(ray Ray, inout rayPayload RayPayload, uint InstanceIndex, uint MeshIndex)
{
    uint NodeInx = 0;
    uint Stack[64];
    uint StackPointer=0;
    bool t=true;
    
    // int MeshIndex=5;
    indexData IndexData = IndexDataBuffer.IndexData[MeshIndex];
    uint NodeStartInx = IndexData.BVHNodeDataStartInx;
    uint TriangleStartInx = IndexData.triangleDataStartInx;
    uint IndexStartInx = IndexData.IndicesDataStartInx;
    uint MaterialIndex = IndexData.MaterialIndex;
    
        

    while(t)
    {
        if(BVHBuffer.Nodes[NodeStartInx + NodeInx].TriangleCount>0)
        {
            for(uint i=0; i<BVHBuffer.Nodes[NodeStartInx + NodeInx].TriangleCount; i++)
            {
                uint Index = TriangleStartInx + IndicesBuffer.Indices[IndexStartInx + BVHBuffer.Nodes[NodeStartInx + NodeInx].LeftChildOrFirst + i] ;
                RayTriangleInteresection(Ray, 
                                         TriangleBuffer.Triangles[Index], 
                                         RayPayload, 
                                         InstanceIndex, 
                                         Index,
                                         MaterialIndex);
            }
            if(StackPointer==0) break;
            else NodeInx = Stack[--StackPointer];
            continue;
        }

        uint Child1 = BVHBuffer.Nodes[NodeStartInx + NodeInx].LeftChildOrFirst;
        uint Child2 = BVHBuffer.Nodes[NodeStartInx + NodeInx].LeftChildOrFirst+1;

        float Dist1 = RayAABBIntersection(Ray, BVHBuffer.Nodes[Child1 + NodeStartInx].AABBMin, BVHBuffer.Nodes[Child1 + NodeStartInx].AABBMax, RayPayload);
        float Dist2 = RayAABBIntersection(Ray, BVHBuffer.Nodes[Child2 + NodeStartInx].AABBMin, BVHBuffer.Nodes[Child2 + NodeStartInx].AABBMax, RayPayload);
        if(Dist1 > Dist2) {
            float tmpDist = Dist2;
            Dist2 = Dist1;
            Dist1 = tmpDist;

            uint tmpChild = Child2;
            Child2 = Child1;
            Child1 = tmpChild;
        }

        if(Dist1 == 1e30f)
        {
            if(StackPointer==0) break;
            else NodeInx = Stack[--StackPointer];
        }
        else
        {
            NodeInx = Child1;
            if(Dist2 != 1e30f)
            {
                Stack[StackPointer++] = Child2;
            }   
        }
    }
}

void IntersectInstance(ray Ray, inout rayPayload RayPayload, uint InstanceIndex)
{
    mat4 InverseTransform = TLASInstancesBuffer.Instances[InstanceIndex].InverseTransform;
    Ray.Origin = (InverseTransform * vec4(Ray.Origin, 1)).xyz;
    Ray.Direction = (InverseTransform * vec4(Ray.Direction, 0)).xyz;
    Ray.InverseDirection = 1.0f / Ray.Direction;

    IntersectBVH(Ray, RayPayload, TLASInstancesBuffer.Instances[InstanceIndex].Index, TLASInstancesBuffer.Instances[InstanceIndex].MeshIndex);
}

void IntersectTLAS(ray Ray, inout rayPayload RayPayload)
{
    Ray.InverseDirection = 1.0f / Ray.Direction;
    uint NodeInx = 0;
    uint Stack[64];
    uint StackPtr=0;
    while(true)
    {
        //If we hit the leaf, check intersection with the bvhs
        if(TLASNodes.Nodes[NodeInx].LeftRight==0)
        {
            IntersectInstance(Ray, RayPayload, TLASNodes.Nodes[NodeInx].BLAS);
            
            if(StackPtr == 0) break;
            else NodeInx = Stack[--StackPtr];
            continue;
        }

        //Check if hit any of the children
        uint Child1 = TLASNodes.Nodes[NodeInx].LeftRight & 0xffff;
        uint Child2 = TLASNodes.Nodes[NodeInx].LeftRight >> 16;
        
        float Dist1 = RayAABBIntersection(Ray, TLASNodes.Nodes[Child1].AABBMin, TLASNodes.Nodes[Child1].AABBMax, RayPayload);
        float Dist2 = RayAABBIntersection(Ray, TLASNodes.Nodes[Child2].AABBMin, TLASNodes.Nodes[Child2].AABBMax, RayPayload);
        if(Dist1 > Dist2) { //Swap if dist 2 is closer
            float tmpDist = Dist2;
            Dist2 = Dist1;
            Dist1 = tmpDist;

            uint tmpChild = Child2;
            Child2 = Child1;
            Child1 = tmpChild;            
        }
        
        if(Dist1 == 1e30f) //We didn't hit a child
        {
            if(StackPtr == 0) break; //There's no node left to explore
            else NodeInx = Stack[--StackPtr]; //Go to the next node in the stack
        }
        else //We hit a child
        {
            NodeInx = Child1; //Set the current node to the first child
            if(Dist2 != 1e30f) Stack[StackPtr++] = Child2; //If we also hit the other node, add it in the stack
        }

    }
}


void main() 
{	  
    ivec2 dim = ivec2(
        gl_NumWorkGroups.x * 16,
        gl_NumWorkGroups.y * 16 
    );
    // vec2 uv = vec2(gl_GlobalInvocationID.xy) / dim;
    
    ray Ray;
    // Ray.Origin = (SceneUbo.Data.InvView * vec4(0.0, 0.0, 0.0, 1.0)).xyz;
    // // vec4 Target = SceneUbo.Data.InvProjection * vec4((vec2(gl_GlobalInvocationID.xy)) / dim * 2.0 - 1.0, 0.0, 1.0);
    // Ray.Direction = (SceneUbo.Data.InvView * vec4(normalize(Target.xyz), 0.0)).xyz;

    RayPayload.Distance = 1e30f;

    if(ubo.ShouldAccumulate>0)
    {
        RayPayload.RandomState = uint(uint(gl_GlobalInvocationID.x) * uint(1973) + uint(gl_GlobalInvocationID.y) * uint(9277) + uint(ubo.currentSamplesCount) * uint(26699)) | uint(1); 
        RayPayload.Depth=0;
        vec3 SamplesColor = vec3(0.0);
        
        if(ubo.currentSamplesCount < ubo.MaxSamples)
        {
            
            for(uint i=0; i<ubo.samplesPerFrame; i++)
            {
                vec2 jitter = vec2(RandomUnilateral(RayPayload.RandomState), RandomUnilateral(RayPayload.RandomState)) - 0.5;
                Ray.Origin = (SceneUbo.Data.InvView * vec4(0.0, 0.0, 0.0, 1.0)).xyz;
                vec4 Target = SceneUbo.Data.InvProjection * vec4((vec2(gl_GlobalInvocationID.xy) + jitter) / dim * 2.0 - 1.0, 0.0, 1.0);
                Ray.Direction = (SceneUbo.Data.InvView * vec4(normalize(Target.xyz), 0.0)).xyz;
                
                vec3 V = -Ray.Direction.xyz;
                vec3 Attenuation = vec3(1.0);
                vec3 Radiance = vec3(0);
                float alpha = 1.0;
                

                for(int j=0; j<ubo.rayBounces; j++)
                {
                    IntersectTLAS(Ray,RayPayload);
                    //Sky
                    {
                        if(RayPayload.Distance == 1e30f)
                        {
                            if(SceneUbo.Data.BackgroundType ==BACKGROUND_TYPE_CUBEMAP)
                            {
                                // vec3 SkyDirection = Direction.xyz;
                                // SkyDirection.y *=-1;
                                // Radiance += Attenuation * SceneUbo.Data.BackgroundIntensity * texture(IrradianceMap, SkyDirection).rgb;
                                Radiance += Attenuation * SceneUbo.Data.BackgroundIntensity * SceneUbo.Data.BackgroundColor;
                            }
                            else if(SceneUbo.Data.BackgroundType ==BACKGROUND_TYPE_COLOR)
                            {
                                Radiance += Attenuation * SceneUbo.Data.BackgroundIntensity * SceneUbo.Data.BackgroundColor;
                            }
                            break;
                        }
                    }

                    if(RayPayload.Distance < 1e30f)
                    {
                        material Material = MaterialData.Data[RayPayload.MaterialIndex];
                        triangleExtraData ExtraData = TriangleExBuffer.TrianglesEx[RayPayload.PrimitiveIndex];
                        vec2 UV = 
                            ExtraData.UV1 * RayPayload.U + 
                            ExtraData.UV2 * RayPayload.V +
                            ExtraData.UV0 * (1 - RayPayload.U - RayPayload.V);
                        
                        RayPayload.Roughness = Material.Roughness;
                        RayPayload.Metallic = Material.Metallic;
                        
                        RayPayload.Color = Material.BaseColor;
                        if(Material.BaseColorTextureID >=0 && Material.UseBaseColorMap>0)
                        {
                            vec4 TextureColor = texture(textures[Material.BaseColorTextureID], UV);
                            TextureColor.rgb *= pow(TextureColor.rgb, vec3(2.2));
                            RayPayload.Color *= TextureColor.rgb;
                        }

                        // Roughness / metallic
                        RayPayload.Roughness = Material.Roughness;
                        RayPayload.Metallic = Material.Metallic;
                        if(Material.MetallicRoughnessTextureID >=0 && Material.UseMetallicRoughnessMap>0)
                        {
                            vec2 RoughnessMetallic = texture(textures[Material.MetallicRoughnessTextureID], UV).rg;
                            RayPayload.Metallic *= RoughnessMetallic.r;
                            RayPayload.Roughness *= RoughnessMetallic.g;
                        }
                        
                        
                        // Emission
                        RayPayload.Emission = Material.Emission * Material.EmissiveStrength;
                        if(Material.EmissionMapTextureID >=0 && Material.UseEmissionMap>0)
                        {
                            RayPayload.Emission *= texture(textures[Material.EmissionMapTextureID], UV).rgb;
                        }
                                                    
                        
                        RayPayload.Normal = 
                            ExtraData.Normal1 * RayPayload.U + 
                            ExtraData.Normal2 * RayPayload.V +
                            ExtraData.Normal0 * (1 - RayPayload.U - RayPayload.V);                           
                    }

                    
                    Radiance += Attenuation * RayPayload.Emission;

                    //Sample lights
                    if(SceneUbo.Data.BackgroundType ==BACKGROUND_TYPE_DIRLIGHT)
                    {
                        // Prepare data needed to evaluate the light
                        vec3 LightDir= normalize(-SceneUbo.Data.LightDirection);;
                        vec3 LightTangent   = normalize(cross(LightDir, vec3(0.0f, 1.0f, 0.0f)));
                        vec3 LightBitangent = normalize(cross(LightTangent, LightDir));
                        float Random1 = RandomUnilateral(RayPayload.RandomState);
                        float Random2 = RandomUnilateral(RayPayload.RandomState);

                        float PointRadius = SceneUbo.Data.LightRadius * Random1;
                        float PointAngle  = Random2 * 2.0f * PI;
                        vec2  DiskPoint   = vec2(PointRadius * cos(PointAngle), PointRadius * sin(PointAngle));    
                        vec3 L = normalize(LightDir + DiskPoint.x * LightTangent + DiskPoint.y * LightBitangent);

                        ray ShadowRay;
                        ShadowRay.Origin = Ray.Origin + RayPayload.Distance * Ray.Direction;
                        ShadowRay.Direction = L;
                        rayPayload ShadowRayPayload;
                        ShadowRayPayload.Distance = 1e30f;
                        IntersectTLAS(ShadowRay,ShadowRayPayload);

                        if(ShadowRayPayload.Distance == 1e30f)
                        {
                            Radiance += Attenuation * EvalCombinedBRDF(RayPayload.Normal, L, V, RayPayload.Color, RayPayload.Metallic) * SceneUbo.Data.BackgroundIntensity * SceneUbo.Data.BackgroundColor;
                        }
                    }


                    if(j == ubo.rayBounces-1) break;
                    
                    // Russian roulette
                    {
                        if (j >= 3)
                        {
                            float q = min(max(Attenuation.x, max(Attenuation.y, Attenuation.z)) + 0.001, 0.95);
                            if (RandomUnilateral(RayPayload.RandomState) > q)
                                break;
                            Attenuation /= q;
                        }
                    }

                    //Eval brdf
                    {
                        int BRDFType = DIFFUSE_TYPE;

                        //If the material is purely metallic, it always samples the specular brdf
                        if (RayPayload.Metallic == 1.0f && RayPayload.Roughness == 0.0f) {
                            BRDFType = SPECULAR_TYPE;
                        } 
                        else 
                        {
                            float BRDFProbability = GetBRDFProbability(RayPayload, V, RayPayload.Normal);
                            float RandomValue = RandomUnilateral(RayPayload.RandomState);
                            if (RandomValue < BRDFProbability) {
                                BRDFType = SPECULAR_TYPE;
                                Attenuation /= BRDFProbability;
                            } else {
                                BRDFType = DIFFUSE_TYPE;
                                Attenuation /= (1.0f - BRDFProbability);
                            }
                        }

                        vec3 brdfWeight;
                        vec2 Xi = vec2(RandomUnilateral(RayPayload.RandomState),RandomUnilateral(RayPayload.RandomState));
                        vec3 ScatterDir = vec3(0);
                        
                        if(BRDFType == DIFFUSE_TYPE)
                        {
                            if (!SampleDiffuseBRDF(Xi, RayPayload.Normal, V,  ScatterDir, brdfWeight)) {
                                break;
                            }
                        }
                        else if(BRDFType == SPECULAR_TYPE)
                        {
                            if (!SampleSpecularBRDF(Xi, RayPayload.Normal, V,  ScatterDir, brdfWeight)) {
                                break;
                            }
                        }

                        //the weights already contains color * brdf * cosine term / pdf
                        Attenuation *= brdfWeight;						
                        Ray.Origin = Ray.Origin + RayPayload.Distance * Ray.Direction;
                        Ray.Direction = ScatterDir;
                        RayPayload.Distance = 1e30f;
                    } 
                }
                SamplesColor += Radiance;			
            }
        }
        //Load previous frame
        vec3 LastFrameColor = vec3(0);
        if(ubo.samplesPerFrame != ubo.currentSamplesCount)
        {
            LastFrameColor = imageLoad(AccumulationImage, ivec2(gl_GlobalInvocationID.xy)).rgb;
        }

        //Add new color to previous color, and add to accumulation buffer
        vec3 AccumulatedColor = LastFrameColor + SamplesColor;
        imageStore(AccumulationImage, ivec2(gl_GlobalInvocationID.xy), vec4(AccumulatedColor, 0));

        //Average, tonemap and set output color
        vec3 Color = AccumulatedColor / (ubo.currentSamplesCount);
        Color = toneMap(Color, SceneUbo.Data.Exposure);
        Color = clamp(Color, 0, 1);
        imageStore(FinalImage, ivec2(gl_GlobalInvocationID.xy), vec4(Color, 0));    
    }
}

