#version 460
#extension GL_EXT_shader_explicit_arithmetic_types_int64 : require
#extension GL_EXT_nonuniform_qualifier : enable

layout (local_size_x = 16, local_size_y = 16) in;

#include "Common/random.glsl"
#include "Common/Material.glsl"
#include "Common/Tonemapping.glsl"

struct triangle
{
    vec3 v0;
    float padding0;
    vec3 v1;
    float padding1;
    vec3 v2;
    float padding2; 
    vec3 Centroid;
    float padding3;     
};

struct triangleExtraData
{
    vec3 Normal0; 
    float padding0;
    vec3 Normal1; 
    float padding1;
    vec3 Normal2; 
    float padding2;
    vec2 UV0, UV1, UV2; 
    vec2 padding3;
};
struct bvhNode
{
    vec3 AABBMin;
    float padding0;
    vec3 AABBMax;
    float padding1;
    uint LeftChildOrFirst;
    uint TriangleCount;
    uvec2 padding2;    
};

struct indexData
{
    uint triangleDataStartInx;
    uint IndicesDataStartInx;
    uint BVHNodeDataStartInx;
    uint MaterialIndex;
};

struct aabb
{
    vec3 Min;
    float pad0;
    vec3 Max;
    float pad1;
};

struct bvhInstance
{
    mat4 InverseTransform;
    aabb Bounds;
    
    uint MeshIndex;
    uint Index;
    ivec2 pad0;
    
    ivec4 pad1;
};

struct tlasNode
{
    vec3 AABBMin;
    uint LeftRight;
    vec3 AABBMax;
    uint BLAS;
};

struct uniformData
{
    uint VertexSize;
    uint CurrentSampleCount;
    int SamplersPerFrame;
    int RayBounces;

    int MaxSamples ;
    int ShouldAccumulate;
    ivec2 Padding;
};


layout (set=0, binding = 0, rgba8) uniform  image2D FinalImage;
layout (set=0, binding = 1) readonly buffer triangleBuffer
{
    triangle Triangles[];
} TriangleBuffer;

layout (set=0, binding = 2) readonly buffer triangleExBuffer
{
    triangleExtraData TrianglesEx[];
} TriangleExBuffer;

layout (set=0, binding = 3) readonly buffer bvhBuffer
{
    bvhNode Nodes[];
} BVHBuffer;

layout (set=0, binding = 4) readonly buffer indicesBuffer
{
    uint Indices[];
} IndicesBuffer;

layout (set=0, binding = 5) readonly buffer indexDataBuffer
{
    indexData IndexData[];
} IndexDataBuffer;

layout (set=0, binding = 6) readonly buffer tlasInstancesBuffer
{
    bvhInstance Instances[];
} TLASInstancesBuffer;

layout (set=0, binding = 7) readonly buffer tlasNodes
{
    tlasNode Nodes[];
} TLASNodes;

layout (set=0, binding = 8) readonly buffer materialData
{
    material Data[];
} MaterialData;

layout(set = 0, binding = 9) uniform sampler2D[] textures;

#include "Common/ubo.glsl"
layout(set = 0, binding = 10) uniform UniformData { Ubo ubo; };

layout (set=0, binding = 11, rgba8) uniform  image2D AccumulationImage;

#include "Common/SceneUBO.glsl"
layout (set=1, binding = 0) uniform UBO 
{
    sceneUbo Data;
} SceneUbo;



struct ray
{
    vec3 Origin;
    vec3 Direction;
    vec3 InverseDirection;
};


struct rayPayload
{
    float Distance;
    vec3 Emission;
    
    vec3 Color;
	float Roughness;
    
    uint InstanceIndex;
    uint PrimitiveIndex;
    uint RandomState;
	uint Depth;
    
	vec3 Normal;
	uint MaterialIndex;
    
    float U, V;
    vec2 padding;
};

float RayAABBIntersection(ray Ray, vec3 AABBMin, vec3 AABBMax, inout  rayPayload RayPayload)
{
    float tx1 = (AABBMin.x - Ray.Origin.x) * Ray.InverseDirection.x, tx2 = (AABBMax.x - Ray.Origin.x) * Ray.InverseDirection.x;
    float tmin = min( tx1, tx2 ), tmax = max( tx1, tx2 );
    float ty1 = (AABBMin.y - Ray.Origin.y) * Ray.InverseDirection.y, ty2 = (AABBMax.y - Ray.Origin.y) * Ray.InverseDirection.y;
    tmin = max( tmin, min( ty1, ty2 ) ), tmax = min( tmax, max( ty1, ty2 ) );
    float tz1 = (AABBMin.z - Ray.Origin.z) * Ray.InverseDirection.z, tz2 = (AABBMax.z - Ray.Origin.z) * Ray.InverseDirection.z;
    tmin = max( tmin, min( tz1, tz2 ) ), tmax = min( tmax, max( tz1, tz2 ) );
    if(tmax >= tmin && tmin < RayPayload.Distance && tmax > 0) return tmin;
    else return 1e30f;    
}

void RayTriangleInteresection(ray Ray, triangle Triangle, inout rayPayload RayPayload, uint InstanceIndex, uint PrimitiveIndex, uint MaterialIndex)
{
    vec3 Edge1 = Triangle.v1 - Triangle.v0;
    vec3 Edge2 = Triangle.v2 - Triangle.v0;

    vec3 h = cross(Ray.Direction, Edge2);
    float a = dot(Edge1, h);
    if(a > -0.0001f && a < 0.0001f) return; //Ray is parallel to the triangle
    
    float f = 1 / a;
    vec3 s = Ray.Origin - Triangle.v0;
    float u = f * dot(s, h);
    if(u < 0 || u > 1) return;

    vec3 q = cross(s, Edge1);
    float v = f * dot(Ray.Direction, q);
    if(v < 0 || u + v > 1) return;
    
    float t = f * dot(Edge2, q);
    if(t > 0.0001f && t < RayPayload.Distance) {
        RayPayload.U = u;
        RayPayload.V = v;
        RayPayload.InstanceIndex = InstanceIndex;
        RayPayload.Distance = t;
        RayPayload.PrimitiveIndex = PrimitiveIndex;
        RayPayload.MaterialIndex = MaterialIndex;
    }
}

void IntersectBVH(ray Ray, inout rayPayload RayPayload, uint InstanceIndex, uint MeshIndex)
{
    uint NodeInx = 0;
    uint Stack[64];
    uint StackPointer=0;
    bool t=true;
    
    // int MeshIndex=5;
    indexData IndexData = IndexDataBuffer.IndexData[MeshIndex];
    uint NodeStartInx = IndexData.BVHNodeDataStartInx;
    uint TriangleStartInx = IndexData.triangleDataStartInx;
    uint IndexStartInx = IndexData.IndicesDataStartInx;
    uint MaterialIndex = IndexData.MaterialIndex;
    
        

    while(t)
    {
        if(BVHBuffer.Nodes[NodeStartInx + NodeInx].TriangleCount>0)
        {
            for(uint i=0; i<BVHBuffer.Nodes[NodeStartInx + NodeInx].TriangleCount; i++)
            {
                uint Index = TriangleStartInx + IndicesBuffer.Indices[IndexStartInx + BVHBuffer.Nodes[NodeStartInx + NodeInx].LeftChildOrFirst + i] ;
                RayTriangleInteresection(Ray, 
                                         TriangleBuffer.Triangles[Index], 
                                         RayPayload, 
                                         InstanceIndex, 
                                         Index,
                                         MaterialIndex);
            }
            if(StackPointer==0) break;
            else NodeInx = Stack[--StackPointer];
            continue;
        }

        uint Child1 = BVHBuffer.Nodes[NodeStartInx + NodeInx].LeftChildOrFirst;
        uint Child2 = BVHBuffer.Nodes[NodeStartInx + NodeInx].LeftChildOrFirst+1;

        float Dist1 = RayAABBIntersection(Ray, BVHBuffer.Nodes[Child1 + NodeStartInx].AABBMin, BVHBuffer.Nodes[Child1 + NodeStartInx].AABBMax, RayPayload);
        float Dist2 = RayAABBIntersection(Ray, BVHBuffer.Nodes[Child2 + NodeStartInx].AABBMin, BVHBuffer.Nodes[Child2 + NodeStartInx].AABBMax, RayPayload);
        if(Dist1 > Dist2) {
            float tmpDist = Dist2;
            Dist2 = Dist1;
            Dist1 = tmpDist;

            uint tmpChild = Child2;
            Child2 = Child1;
            Child1 = tmpChild;
        }

        if(Dist1 == 1e30f)
        {
            if(StackPointer==0) break;
            else NodeInx = Stack[--StackPointer];
        }
        else
        {
            NodeInx = Child1;
            if(Dist2 != 1e30f)
            {
                Stack[StackPointer++] = Child2;
            }   
        }
    }
}

void IntersectInstance(ray Ray, inout rayPayload RayPayload, uint InstanceIndex)
{
    mat4 InverseTransform = TLASInstancesBuffer.Instances[InstanceIndex].InverseTransform;
    Ray.Origin = (InverseTransform * vec4(Ray.Origin, 1)).xyz;
    Ray.Direction = (InverseTransform * vec4(Ray.Direction, 0)).xyz;
    Ray.InverseDirection = 1.0f / Ray.Direction;

    IntersectBVH(Ray, RayPayload, TLASInstancesBuffer.Instances[InstanceIndex].Index, TLASInstancesBuffer.Instances[InstanceIndex].MeshIndex);
}

void IntersectTLAS(ray Ray, inout rayPayload RayPayload)
{
    Ray.InverseDirection = 1.0f / Ray.Direction;
    uint NodeInx = 0;
    uint Stack[64];
    uint StackPtr=0;
    while(true)
    {
        //If we hit the leaf, check intersection with the bvhs
        if(TLASNodes.Nodes[NodeInx].LeftRight==0)
        {
            IntersectInstance(Ray, RayPayload, TLASNodes.Nodes[NodeInx].BLAS);
            
            if(StackPtr == 0) break;
            else NodeInx = Stack[--StackPtr];
            continue;
        }

        //Check if hit any of the children
        uint Child1 = TLASNodes.Nodes[NodeInx].LeftRight & 0xffff;
        uint Child2 = TLASNodes.Nodes[NodeInx].LeftRight >> 16;
        
        float Dist1 = RayAABBIntersection(Ray, TLASNodes.Nodes[Child1].AABBMin, TLASNodes.Nodes[Child1].AABBMax, RayPayload);
        float Dist2 = RayAABBIntersection(Ray, TLASNodes.Nodes[Child2].AABBMin, TLASNodes.Nodes[Child2].AABBMax, RayPayload);
        if(Dist1 > Dist2) { //Swap if dist 2 is closer
            float tmpDist = Dist2;
            Dist2 = Dist1;
            Dist1 = tmpDist;

            uint tmpChild = Child2;
            Child2 = Child1;
            Child1 = tmpChild;            
        }
        
        if(Dist1 == 1e30f) //We didn't hit a child
        {
            if(StackPtr == 0) break; //There's no node left to explore
            else NodeInx = Stack[--StackPtr]; //Go to the next node in the stack
        }
        else //We hit a child
        {
            NodeInx = Child1; //Set the current node to the first child
            if(Dist2 != 1e30f) Stack[StackPtr++] = Child2; //If we also hit the other node, add it in the stack
        }

    }
}


void main() 
{	  
    ivec2 dim = imageSize(FinalImage);
    vec2 uv = vec2(gl_GlobalInvocationID.xy) / dim;
    
    ray Ray;
    Ray.Origin = (SceneUbo.Data.InvView * vec4(0.0, 0.0, 0.0, 1.0)).xyz;
    vec4 Target = SceneUbo.Data.InvProjection * vec4((vec2(gl_GlobalInvocationID.xy)) / dim * 2.0 - 1.0, 0.0, 1.0);
    Ray.Direction = (SceneUbo.Data.InvView * vec4(normalize(Target.xyz), 0.0)).xyz;
    Ray.InverseDirection = 1 / Ray.Direction;

    rayPayload PayLoad;
    PayLoad.Distance = 1e30f;
    // IntersectInstance(Ray, PayLoad, 0);
    // IntersectBVH(Ray, PayLoad, 0,27);
    IntersectTLAS(Ray,PayLoad);
    
    vec3 SamplesColor = vec3(0);
    if(PayLoad.Distance < 1e30f)
    {
        material Material = MaterialData.Data[PayLoad.MaterialIndex];
        triangleExtraData ExtraData = TriangleExBuffer.TrianglesEx[PayLoad.PrimitiveIndex];
        
        vec2 UV = 
            ExtraData.UV1 * PayLoad.U + 
            ExtraData.UV2 * PayLoad.V +
            ExtraData.UV0 * (1 - PayLoad.U - PayLoad.V);
        vec3 Normal = 
            ExtraData.Normal1 * PayLoad.U + 
            ExtraData.Normal2 * PayLoad.V +
            ExtraData.Normal0 * (1 - PayLoad.U - PayLoad.V);
                    

        vec3 BaseColor = Material.BaseColor;
        if(Material.BaseColorTextureID >=0 && Material.UseBaseColorMap>0)
        {
            vec4 TextureColor = texture(textures[Material.BaseColorTextureID], UV);
            TextureColor.rgb *= pow(TextureColor.rgb, vec3(2.2));
            BaseColor *= TextureColor.rgb;
        }


        SamplesColor += BaseColor;
        SamplesColor = toneMap(SamplesColor, SceneUbo.Data.Exposure);        
    }


    //Load previous frame
    vec3 LastFrameColor = vec3(0);
    if(ubo.samplesPerFrame != ubo.currentSamplesCount)
    {
        LastFrameColor = imageLoad(AccumulationImage, ivec2(gl_GlobalInvocationID.xy)).rgb;
    }

    //Add new color to previous color, and add to accumulation buffer
    vec3 AccumulatedColor = LastFrameColor + SamplesColor;
    imageStore(AccumulationImage, ivec2(gl_GlobalInvocationID.xy), vec4(AccumulatedColor, 0));

    //Average, tonemap and set output color
    vec3 Color = AccumulatedColor / ubo.currentSamplesCount;
    Color = toneMap(Color, SceneUbo.Data.Exposure);
    Color = clamp(Color, 0, 1);
    imageStore(FinalImage, ivec2(gl_GlobalInvocationID.xy), vec4(Color, 0));    
}

